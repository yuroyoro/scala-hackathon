関数編
----------------------------
Scalaの関数は、ファーストクラス関数です。関数オブジェクトを変数に代入したり、"関数を生成する関数"(高階関数)を定義したり、クロージャとして利用することができます。

関数の宣言については先ほど説明しましたので、具体的にScalaの関数が持つ強力な機能をこれから紹介します。


関数の呼び出し
___________________________

Scalaで関数を呼び出すには、Javaなどと同じように、関数を持っているオブジェクトに.(ドット)をつけて呼び出します。

.. code-block:: scala

  scala> val s = "Foo"
  s: java.lang.String = Foo

  scala> s.charAt(0)
  res16: Char = F

引数を取らない関数を呼び出す場合、()を省略できます。ただし関数の宣言でdef foo = {...}のように予め()なしで宣言されている関数を呼び出すときには、()をつけて呼び出すとエラーになります。

.. code-block:: scala

  scala> s.length()
  res17: Int = 3

  scala> s.length
  res18: Int = 3

引数なしまたは1引数の関数を呼び出す場合、.(ドット)の変わりにスペースを利用することができます。

.. code-block:: scala

  scala> s.length()
  res17: Int = 3

  scala> s length
  res19: Int = 3

１引数の関数を呼び出す場合、引数の指定で()を利用する変わりに、スペースの後に引数を指定することでも呼び出すことが可能です。

.. code-block:: scala

  scala> s.charAt(2)
  res20: Char = o

  scala> s charAt 2
  res21: Char = o

  scala> (s.charAt(2)).toLong
  res39: Long = 111

  scala> s charAt 2 toLong
  res40: Long = 111

このような記述が許されているため、ScalaではDSLのように自然言語に近い形の記述ができるようになっているのです。


ファーストクラス関数
___________________________

Scalaの関数は、ファーストクラスオブジェクトです。これは、関数をオブジェクトとして扱い、変数に"関数オブジェクト"を代入したり、関数の引数に"関数オブジェクト"を渡して呼び出し先の関数から"関数オブジェクト"を呼び出す、"関数オブジェクト"を生成する関数を定義する、などが可能になる、ということを意味します。

具体的な例を見てみましょう。

.. code-block:: scala

  scala> def isEven( n:Int ):Boolean = { n % 2 == 0 }
  isEven: (Int)Boolean

  scala> val func = isEven _
  func: (Int) => Boolean = <function>

  scala> func( 3 )
  res4: Boolean = false

最初に、"isEven"というInt型の引数を一つ取る関数を定義しています。

次に、この関数の"関数オブジェクト"を、funcという変数に代入しています。
関数名のあとにスペースを空けて、"_"(アンダースコア)を書くと、その関数のオブジェクトを取り出すことができるのです(正確には、部分適用された関数ですが)。

最後に、func変数が保持している関数(実態はisEven関数)に引数3を渡して呼び出しています。

関数の"型"
___________________________

先ほどの例で、func変数に代入した際に、以下のように出力されました。この出力は何を表しているのでしょうか?

.. code-block:: scala

  func: (Int) => Boolean = <function>

この"(Int) => Boolean"は、その関数の"型"を表しています。この表記の意味は、Int型の引数をひとつ取り、Boolean型の結果を返す関数であることを表現しているのです。

IntとStringの二つの引数を取って、List[String]型の結果を返す関数は、"(Int,String) => List[String]となりますし、String型の引数を取って何も返さない(Unit型)関数は、"(String) => Unit"となります。

関数を引数に取る関数
___________________________

関数はオブジェクトですので、ある関数の引数に"関数"を渡すことができます。具体的には、どのように定義するのでしょうか。以下の例を見てください。

.. code-block:: scala

  def boolean2String( f:(Int) => Boolean,  n:Int ) = {
    if( f( n ) ) "偶数" else "奇数"
  }

このboolean2String関数の引数の宣言に注目してください。第1引数が"f:(Int) => Boolean"と書かれています。
これは「fという引数の型は(Int) => Booleanである。」という意味です。つまり第一引数fは、Int型の引数をひとつ取ってBoolean型の結果を返す関数オブジェクトである、ということになります。

引数名の後の:(コロン)以降は、その引数の型を指定することを思い出してください。単純に、引数fの型を、先ほど説明した"関数の型"の表記で指定しているだけなのです。

では、このboolean2Stringを呼び出してみましょう。以前に定義したisEven関数を第1引数に渡すことにします。

.. code-block:: scala

  scala> val func = isEven _
  func: (Int) => Boolean = <function>

  scala> boolean2String( func ,  3 )
  res6: java.lang.String = 奇数

  scala> boolean2String( isEven _ ,  3 )
  res7: java.lang.String = 奇数

  scala> boolean2String( isEven  ,  3 )
  res8: java.lang.String = 奇数


関数リテラル
___________________________

先ほどの例では、一度"def"キーワードを利用してisEven関数を定義して、変数funcに代入するということを行いました。ただ、わざわざ名前をつけて定義するまでもない、使い捨ての関数をその場で定義したい場合もあるでしょう。関数の宣言と代入を、一度に行う方法はないのでしょうか?

その答えが、関数リテラルです。文字列は、その場で"foo"のように生成できて、わざわざ"new String"aaa")"なんて書きませんよね?
これと同じことを、関数リテラルは実現します。

関数リテラルは、このような書式で記述します。

.. code-block:: scala

  (引数1:型, 引数2:型, ･･･) => { 処理 }

最初の()の中身は、defで関数を宣言する場合の引数の定義と同じです。
その引数の宣言の()のあとに"=>"(rocket-dashというらしいです)を書いて、その後に関数の具体的な処理を記述する形になります。

結果型を宣言する必要はありません。結果型は、記述した処理の内容から型推論されるためです。

具体例を見てましょう。以前定義したisEven関数を関数リテラルで変数fretに代入してみます。

.. code-blcok:: scala

  scala> val fret:(Int) => Boolean = (n:Int) => { n % 2 == 0 }
  fret: (Int) => Boolean = <function>

  scala> val fret = (n:Int) =>  n % 2 == 0
  fret: (Int) => Boolean = <function>

この２つのコードは、どちらも同じことを行っています。
最初の書き方は、きちんと変数fretの型が"(Int) => Boolean"型であることを宣言したうえで、 =の後に関数リテラルで引数nの値が偶数の場合Trueを返す"無名関数"をfretに代入しています。

2番目の書き方は、引数fretの型の宣言を省略し(型推論されるので)、関数リテラルで無名関数を定義しています。関数本体が一行で収まる内容のため、さらに{}も省略してこのような形になっています。

さてここで、"1関数を引数に取る関数"としてboolean2String関数を作ったことを思い出してください。このboolean2String関数の引数に、関数リテラルで無名関数を渡すと、このような書き方になります。

.. code-block:: scala

  scala> boolean2String( (n:Int) => n % 2 == 0 ,  9 )
  res11: java.lang.String = 奇数

第1引数が、関数リテラルの形になっていることに注意して見てください。この記述は、この後説明する引数のプレースホルダーを利用することで、もっと短く書くことができるようになります。

なお、ScalaのコレクションAPIは、関数を引数にとることが多いです。コレクションAPIを利用する際には、このように関数リテラルでその場で関数を定義して引数に渡すということがよく行われます。


引数のプレースホルダー
___________________________

defで関数を宣言するときも、関数リテラルを利用して無名関数を定義する際にも、引数は"引数名:型"の形になっていました。

関数リテラルを利用して無名関数を定義するときに限り、この"引数名"の宣言すら省略することができるのです。

引数名を省略したとしたら、関数本体ではどのように引数に渡された値を受け取ればよいのでしょうか?
プレースホルダーを利用することで、"無名引数"とでもいうべき変数が利用できるようになるのです。

.. code-block:: scala

  scala> val fret:(Int) => Boolean = _ % 2 == 0
  fret: (Int) => Boolean = <function>

この例は、プレースホルダーを利用して、引数名の宣言なしにisEven関数を定義したものです。以前はnという名前の引数担っていた部分が、"_"(アンダースコア)になっていますね。

引数名を省略した場合は、変わりに"_"(アンダースコア)で渡された引数の値を受け取ることができるのです。

引数が2つある関数はどうでしょうか? Int型の引数を2つとって、:wa

高階関数
___________________________

部分適用とカリー化
___________________________

ネストした関数とクロージャ
___________________________


可変長引数
___________________________

